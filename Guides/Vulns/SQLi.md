**It's a vulnerabillity where you can inject some SQL code into the query**
https://book.hacktricks.xyz/pentesting-web/sql-injection
*There are several types, every one with it's own exploitations modes:*

# Boolean based

^b052b6

- In this class of SQLi, you don't have access to the result of the query, but you do have access to a `true`/`false` state (Generally are `auth-bypasses`).
	- Ex: You can bypass a login by doing `' or 1=1 -- -'`
	- You probably also can do `' or '1'=substr(version(),1,1) -- -'`
		- This checks the first char of the `version()` function. By automating this process you can dump pretty much all the database
- This kind of injection are often very slow (since a lot of times you are iterating over every possible character for every character of every item)
	- For this reason, is very complicated to get a full dump of the database (you need to be efficient)

# Error based

^e90d6b

- In this case, you have acces to the errors of the query (**But not the output**). There are several ways to dump data in the error msg
	- I never exploited one before, so i have no further information

# Union based

^98d637

- In this kind of injection, you have access to the output of the query.
	- Ex: You have a filter that does something like `?filter=animal`
	- You can do `?filter=animal'` and get an error (500 internal, maybe the entire output, etc..)
	- You can test for `?filter=' order by 100 -- -`
		- The idea for the order by is to get the number of columns
		- You start at a very large number and goes down untill there is no error
	- Then, you can do something like `?filter=' union select 1,version(),3,4,5 -- -`
		- The idea is to view what field are being representated in the output
			- Maybe you can see all of them, maybe the `1,2,3` are numbers so are not useful, etc...
- This are the fastest and most practical to exploit. 
- You can get a full dump of the database very quickly




# Notes
- The steps generally are:
	- Get a working injection that does not anything, but doesn't gets an error
		- **Ex:** `') -- -`
	- Then, try the union based [[SQLi#^98d637]]
		- Look the output and the src code for errors
		- If there are some, [[SQLi#^e90d6b]]
	- Then, if that does not work, you can try to get an output based on a bypass and perform some kind of [[SQLi#^b052b6]]
- In some cases the payloads doesn't work as expected
	- If something is working rarely (maybe something that should work, just doesn't when you add some keyword)
	- If some words are instantly returning some error
		- Maybe in this case, there is a **WAF** running.
			- Look for WAF bypass
			- maybe `select/**/from/**/` works
- The comments in sql work like `-- comment`
	- The space is important, so you can inject `-- -` in order to ensure that the following will be commented
	- In some cases you can also comment with `#` and `/**/`
		- The last one is useful for bypassing WAFs


# SQLMap
- Is an automation software that allows to perform very simple SQLi attacks
- It works for simple cases, in most complicated envs will not work
- It has a lot of params:
	- `-r req.http` -> Grabs the request from a file (useful for injections with cookies needed)
	- `-p param` -> Tells to `nmap` to use only the specified param to try injections
	- `--batch` -> All yes
	- `--dbs --tables --columns --dump-all` -> Dump databases, tables, columns, or directly all
	- `--second-req` -> Looks the result in another place 
		- **Ex**: You are injecting in a profile stored setting, and the output is reflected in the feed page
	- `--tamper space2comment` -> Useful for WAF bypass
		- **Ex**: converts `') union select version(),2,3,4 -- -'` to `')/**/union/**/select/**/version(),2,3,4/**/-- -'`
